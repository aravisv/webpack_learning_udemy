Package.json 
Contains metadata about project, dependencies, entry point

Npm install webpack webpack-cli —save-dev
Save-dev adds it to devDependencies in package.json

Npx webpack
Webpack bundles with default configurations

Mention any script you want to run in package.json
It will run when you execute ‘npm run <scriptname>’

Ex:

  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "build":"webpack"
  },

Npm run build => webpack will run


Asset modules
Used to import files (fonts, icons, etc) and direct them into output file without configuring additional loaders

Asset/resource - large files
Asset/inline - icons, svgs which are put into js file as data uri. No separate output file
asset - combination of above 2
Asset/source - plain text. injects to js file


We need to mention in webpack how to import a module and which type of resource it is.

  module: {
    rules: [
      {
        test: /\.(png|jpg)$/,
        type: "asset/resource",
      },
    ],
  },

publicPath: tells browser where to load the static assets
Be default publicPath in the output object is set to ‘auto’ in webpack >= 5.
In the earlier versions it was “”

output: {
    filename: "bundle.js",
    path: path.resolve(__dirname, "./dist"),
    publicPath: "dist/",
  },



OR 
publicPath:”url/”


Type: asset/inline 
Increases main output js file size
Converts the image to base64 and injects it to js file

Use case:
If there are 20 small size files like icons, then having them inline our js file will be faster than the browser making 20 http calls

Type: asset
By default
Below 8Kb -> inline
Above 8kb -> resource

Below config is how we can change the default size
<3kB will make it inline
>3kB will make it resource (different path in output dir and hence url)

  module: {
    rules: [
      {
        test: /\.(png|jpg)$/,
        type: "asset",
        parser: {
          dataUrlCondition: {
            maxSize: 3 * 1024, //3kB
          },
        },
      },
    ],
  },


Loaders

transformations that are applied to the source code of a module. They allow you to pre-process files as you import or “load” them

Css-loader : reads the styles
Style-loader : injects those styles to js

JS is based on ECMAScript specifications.
Every time a new feature comes and we use it in our code, it may not work in all browsers since even browsers need to support the latest features.
Thats why we use babel (one of the tools) to convert modern js to older js code.

presets: ['@babel/env'] means it will transform the latest javascript to javascript that all browsers understand,
plugins: ['transform-class-properties'] means it will transform class properties (not EcmaScript 6 classes) to javascript that all browsers understand.

Plugins:
--------

install plugin using --save-dev
coz we dont need plugins for production build
if so, how is it handled in production builds?

Terser Plugin:
To minify/minimize your JavaScript

MiniCssExtractPlugin:
This plugin extracts CSS into separate files.
It creates a CSS file per JS file which contains CSS. 
It supports On-Demand-Loading of CSS and SourceMaps.

we can specify the output css file using below configuration
    new MiniCssExtractPlugin({
      filename: "styles.css",
    })

ex:
<head>
...
<link rel="stylesheet" href="./dist/styles.css"/>
...
</head>


this contains all the styles of all components
and then in the main html file we need to import this css file
usecase: https://github.com/webpack-contrib/mini-css-extract-plugin/issues/42

Browser caching:
browser downloads all the assets required to render the page - js, css, images ...
if there is no changes in file, browser uses the cache
to solve, rename the file everytime we make a code change

ex:
filename: "bundle.[contenthash].js",

clean webpack plugin:
to clean the dist folder

(all paths are relative to output.path in webpack config)
cleanOnceBeforeBuildPatterns - 
deletes the folders before starting the build

    new CleanWebpackPlugin({
      cleanOnceBeforeBuildPatterns: [
        "**/*",
        path.join(process.cwd(), "build/**/*"),
      ],
    }),

this would delete any folders and subdirectories inside the dist, build folders

from webpack 5.20 onwards, there is a clean property, used inside output.
clean:{
  dry:true;
  keep:/\.css/
}

dry:true would indicate which files will be kept
keep will keep this kind of files and delete the rest
but the CleanWebpackPlugin offers more configurations

when we do the browser caching using [contenthash] , the html file doesnt get updated with the new file name
so it gets broken
use HtmlWebpackPlugin

remove publicPath or keep '' 
so that the generated html has the proper references to js and css files inside the dist folder
we can now remove the coded html file, since we have the autogenerated one
(start live server from there)

we can use a template handler for html pages
one of them is handlebars

then the HtmlWebpackPlugin has to be modified a bit for the variables:
    new HtmlWebpackPlugin({
      title: "myWebApp",
      template: "src/index.hbs",
      description: "some metadata description",
    }),

no need to add js, css references in the template.
it will be filled by webpack during build